<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"> </script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processEscapes: true}, jax: ["input/TeX","input/MathML","input/AsciiMath","output/CommonHTML"], extensions: ["tex2jax.js","mml2jax.js","asciimath2jax.js","MathMenu.js","MathZoom.js","AssistiveMML.js", "[Contrib]/a11y/accessibility-menu.js"], TeX: { extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"], equationNumbers: { autoNumber: "AMS" } } }); </script> 


## Hashing with Open Addressing

Hashing with open addressing uses table slots directly to store the elements, as indicated in the picture shown below:
<p style="text-align:center">
    <img src="../images/hashingOpenAddressing1.png">                                                       
</p>
The elements hashed to the same slots should be distributed to different other table slots. However, a previously hashed element may occupy the selected 
alternative slot. Therefore, hashing with open addressing requires a robust collision resolution technique to distribute the elements. 

There are many ways to resolve collisions. We discuss some well-established collision
resolution techniques. We can view the probing function as mapping that can specify a sequencing of probes 
for finding an empty slot in the table. The hash function $$h$$ maps a given universe of keys $$U$$ to $$m$$ table slots. <br>
<p style="text-align:center">
    $$h:U\times \{0, 1, 2, \ldots, m-1\}_{trials} \longrightarrow  \{0, 1, 2, \ldots, m-1\}$$                                          
</p>
The probe sequence is essentially a vector 
<p style="text-align:center">
    $$h(k,1), h(k,2), \ldots, h(k,m)$$                                     
</p>
that is a permutation of $$\{0, 1, 2,\ldots, m-1\}$$. The idea is that the probe sequence should examine all slots of the table to discover
empty slots to resolve a collision. <br>

<strong>Linear Probing</strong>

The simplest collision resolution technique is linear probing. If a collision occurs, it tries to find the sequentially next available empty 
table slot. The method uses the hash function given by 
<p style="text-align:center">
$$(h(k) + i)\mod m$$.
</p>
It forms clusters of hashed elements in a few blocks of table slots. Starting with a random table slot $$x_0\in \{0, 1, \ldots, m-1\}$$, linear probing
generates the probe sequence $$x_0, x_1, \ldots, x_{m-1}$$, where $$x_i = (x_0 + i) \mod m$$. It is possible that many of the slots may be occupied
by other elements having hash values clashing with values in probe sequence. Therefore the length of consecutive occupied slots in the table tend
to increase with linear probing. For example, if $$j$$ consecutive slots are occupied, then the probability of the next element mapping to any of 
them is $$j/m$$.   If the cluster length increases to $$j+1$$, the probability increases 
to $$(j+1)/m$$ for another new element being hashed to the cluster. It means that clusters of longer length tend to grow longer with more insertions.
This phenomenon is called <i>primary clustering</i><br>

<strong>Quadratic Probing</strong>

An alternative to linear probing is quadratic probing. It spreads the colliding elements by generating a probing sequence as follows. Given the first slot $$x_0$$.
the slot for $$i$$th probe is generated by: 
<p style="text-align:center">
$$x_i = (x_0 + ic_1 + i^2c_2)$$, 
</p>
where $$i\in \{0, 1, \ldots, m-1\}$$ and $$c_1$$, $$c_2 \ne 0$$ are constants. Quadratic probing improves performance. It solves primary 
clustering problem as distance between probes are spaced by sequence $$c_1 + c_2, 2c_1+4c_2, 3c_1+9c_2, \ldots$$. 
If two keys $$k_1\ne k_2$$, even if some probes $$i$$ and $$j$$, quadratic probe give $$x_i = y_j$$ then $$x_{i+1}\ne y_{j+1}$$. Therefore,
quadratic probe is less likely to exhibit primary clustering. However, if the two elements $$k_1\ne k_2$$ have the same initial hash value 
$$x_0$$ then quadratic probe generates the same probe sequence. This phenomenon is known as secondary clustering.

<strong>Double Hashing</strong>
 
Double hashing uses two different hash functions $$h_1$$ and $$h_2$$, to generate a probe sequence.
<p style="text-align:center">
$$h(k, i) = (h_1(k) + ih_2(k))\mod m$$, 
</p>
If the initial probe is at slot position $$x_0$$, then the distance between successive positions is $$h_2(k)\mod m$$. Let $$h_2(k) = x_1$$, then $$i$$th probe
generates the slot $$x_i = (x_0 + ix_1)\mod m$$ for $$i\ge 0$$. The value of $$h_2(k)$$ must be relatively prime to hash table size $$m$$ for probing 
all slots. The simplest way we can ensure it is to choose $$m$$ a power of 2, and $$h_2$$ to produce always an odd number. The other alternative 
is to let $$m$$ be a prime number and design $$h_2$$ to produce a positive number less than $$m$$. So, we can let 
<p style="text-align:center">
\begin{array}{rcl}
    h_1(k) & = & k \mod m\\
    h_2(k) & = & 1+ (k\mod m')
\end{array}
</p>
where $$m'$$ is slight less than $$m$$ (it could be $$m-1$$). Each combination of the pair $$h_1$$ and $$h_2$$ provides $$m$$ sequences. Since $$m'= m-1$$, 
double hashing uses probe sequences of size O($$m^2$$). Therefore, it is more random than either linear or quadratic hashing, each of which uses O($$m$$)
probe sequences. The figure below is an example of a double hashing technique to resolve collisions.
<p style="text-align:center">
    <img src="../images/doubleHash.png">
</p>
In the example, we use $$h_1(x) = x \mod 10$$ and $$h_2(x) = x\mod 9$$. The insertion sequence is 67, 27, 39 and 79. So, after 67 has been inserted,
slot 7 is occupied. For inserting 27, we use double hash to find the slot $$(7 + 1\times (1+27\mod 9))\mod 10 = (7 + 1)\mod 10 = 8$$. Similarly,
after hashing 39 in slot 9, we cannot store 79 in the same slot. So, we use double hash to calculate possible new poistion for 79 as
$$(9 + (1+79\mod 9))\mod 10 = 7$$. Since slot 7 is also occupied we have to use $$(9 + 2\times (1+79\mod 9))\mod 10 = 5$$ which is not occupied.
So 79 goes to slot 5.
