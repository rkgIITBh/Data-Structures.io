<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_CHTML"> </script> <script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processEscapes: true}, jax: ["input/TeX","input/MathML","input/AsciiMath","output/CommonHTML"], extensions: ["tex2jax.js","mml2jax.js","asciimath2jax.js","MathMenu.js","MathZoom.js","AssistiveMML.js", "[Contrib]/a11y/accessibility-menu.js"], TeX: { extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"], equationNumbers: { autoNumber: "AMS" } } }); </script> 


## Hashing with Open Addressing

Hashing with open addressing uses table slots directly to store the elements, as indicated in the picture shown below:
<p style="text-align:center">
    <img src="../images/hashingOpenAddressing1.png">                                                       
</p>
The elements hashed to the same slots should be distributed to different other table slots. However, a previously hashed element may occupy the selected 
alternative slot. Therefore, hashing with open addressing requires a robust collision resolution technique to distribute the elements. 

There are many ways to resolve collisions. We discuss some well-established collision
resolution techniques. We can view the probing function as mapping that can specify a sequencing of probes 
for finding an empty slot in the table. The hash function $$h$$ maps a given universe of keys $$U$$ to $$m$$ table slots. <br>
<p style="text-align:center">
    $$h:U\times \{0, 1, 2, \ldots, m-1\}_{trials} \longrightarrow  \{0, 1, 2, \ldots, m-1\}$$                                          
</p>
The probe sequence is essentially a vector 
<p style="text-align:center">
    $$h(k,1), h(k,2), \ldots, h(k,m)$$                                     
</p>
that is a permutation of $$\{0, 1, 2,\ldots, m-1\}$$. The idea is that the probe sequence should examine all slots of the table to discover
empty slots to resolve a collision. <br>

<strong>Linear Probing</strong>

The simplest collision resolution technique is linear probing. If a collision occurs, it tries to find the sequentially next available empty 
table slot. The method uses the hash function given by 
<p style="text-align:center">
$$(h(k) + i)\mod m$$.
</p>
It forms clusters of hashed elements in a few blocks of table slots. Starting with a random table slot $$x_0\in \{0, 1, \ldots, m-1\}$$, linear probing
generates the probe sequence $$x_0, x_1, \ldots, x_{m-1}$$, where $$x_i = (x_0 + i) \mod m$$. Therefore, it clusters elements that hash
to the same table slot. It is called <i>primary clustering</i>. We can analyze the effect of primary clustering as follows. If $$j$$ consecutive slots
are occupied, then the probability of the next element mapping to any of them is $$j/m$$. If the cluster length increases to $$j+1$$, the probability increases 
to $$(j+1)/m$$ for another new element being hashed to the cluster. It means that large clusters tend to grow larger with more insertions.<br>

<strong>Quadratic Probing</strong>

An alternative to linear probing is quadratic probing. It spreads the colliding elements by generating a probing sequence as follows. Given the first slot $$x_0$$.
the slot for $$i$$th probe is generated by: 
<p style="text-align:center">
$$x_i = (x_0 + ic_1 + i^2c_2)$$, 
</p>
where $$i\in \{0, 1, \ldots, m-1\}$$ and $$c_1$$, $$c_2 \ne 0$$ are constants. <br>

 <strong>Double Hashing</strong>
 
 Double hashing uses two different hash functions $$h_1$$ and $$h_2$$, to generate a probe sequence.
 <p style="text-align:center">
$$h(k, i) = (h_1(k) + ih_2(k))\mod m$$, 
</p>
If the initial probe is at slot position $$x_0$$, then the distance between successive positions is $$h_2(k)\mod m$$. Let $$h_2(k) = x_1$$, then $$i$$th probe
generates the slot $$x_i = (x_0 + ix_1)\mod m$$ for $$i\ge 0$$. The value of $$h_2(k)$$ must be relatively prime to hash table size $$m$$ for probing 
all slots. The simplest way we can ensure it is to choose $$m$$ a power of 2, and $$h_2$$ to produce always an odd number. The other alternative 
is to let $$m$$ be a prime number and design $$h_2$$ to produce a positive number less than $$m$$. So, we can let 
<p style="text-align:center">
\begin{array}{rcl}
    h_1(k) & = & k \mod m\\
    h_2(k) & = & 1+ (k\mod m')
\end{array}
</p>
where $$m'$$ is slight less than $$m$$ (it could be $$m-1$$). Each combination of the pair $$h_1$$ and $$h_2$$ provides $$m$$ sequences. Since $$m'= m-1$$, 
double hashing uses probe sequences of size O($$m^2$$). Therefore, it is more random than either linear or quadratic hashing, each of which uses O($$m$$)
probe sequences. The figure below is an example of a double hashing technique to resolve collisions.
<p style="text-align:center">
    <img src="../images/doubleHash.png">
</p>
In the example, we use $$h_1(x) = x \mod 10$$ and $$h_2(x) = x\mod 7$$. The insertion sequence is 67, 27, 39 and 79. So, after 67 has been inserted,
slot 7 is occupied. For inserting 27, we use double hash to find the slot $$(7 + 1\times (1+27\mod 9))\mod 10 = (7 + 1)\mod 10 = 8$$. Similarly,
after hashing 39 in slot 9, we cannot store 79 in the same slot. So, we use double hash to calculate possible new poistion for 79 as
$$(9 + (1+79\mod 9))\mod 10$$
